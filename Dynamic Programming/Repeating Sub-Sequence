Given a string, find if there is any sub-sequence that repeats itself.
A sub-sequence of a string is defined as a sequence of characters generated by deleting some characters in the string without changing the order of the remaining characters.

Input:
string

Output:

0/1
0 -> No
1 -> Yes 
Example:

abab ------> yes, ab is repeated. So, return 1. 
abba ------> No, a and b follow different order. So, return 0. 
NOTE : sub-sequence length should be greater than or equal to 2

############################################

bool findLCS(string A, string B,int m,int n){
    //so i we do it
    //1: we can include current index element of A in subseqmce(A+1,B)
    //2: we can do same for B...(A,B+1)
    //3: comare bhth them don't skip.. if qeual include it  
    //max among all 3 will be answer
    
   return true;
    
    
}

int Solution::anytwo(string A) {
    //it like finding the longest common subseqence
    //if length >1 return 1
   // return findLCS(A,A,0,0);
   
   int m=A.size();
   vector<vector<int>> dp(m+1, vector<int>(m+1,0));
   
   for(int i=0;i<=m;i++)
     for(int j=0;j<=m ;j++)
     {
         
         if(i==0||j==0)continue;
         
         //now three condition
         //note this part indirectly handle the case of a[i-1]!=a[j-1]
         //if a[i-1]!=a[j-1] , these are the two thing we do
         //Why we wrote it first? becuase it prevent the duplcate code.how?
         //even in a[i-1]==a[j-1] condition, we can chose not to include the current indexes
         //in such scenarea i have to take max of (condition in a[i-1]!=a[j-1] ,consition in a[i-1]=a[j-1])
         //so since anyway we have to write this , we include it first in our code
         int temp1= max(dp[i-1][j],dp[i][j-1]);
         dp[i][j]=temp1;
         if(A[i-1]==A[j-1])
         {
             if(i-1 != j-1)
             {
                int temp2=dp[i-1][j-1] +1;
                dp[i][j]=max(temp1,temp2);
             }
         }
     }
     
     //cout<<"dp "<<dp[m][m];
  return dp[m][m]>1? 1:0;
}
